<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content="Evernote Mac 7.14 (458244)"/><meta name="altitude" content="294.9998474121094"/><meta name="author" content="Suhas Sudhish"/><meta name="created" content="2020-01-23 09:42:57 +0000"/><meta name="latitude" content="48.77096557617188"/><meta name="longitude" content="9.156888950314706"/><meta name="source" content="desktop.mac"/><meta name="updated" content="2020-01-23 13:52:55 +0000"/><title>JS Behind the scenes</title></head><body><div><img src="JS%20Behind%20the%20scenes.html.resources/Screenshot%202020-01-23%20at%2010.42.42.png" height="1180" width="2284"/><br/></div><div><br/></div><div><br/></div><ul><li><div>JS Engine executes the code. </div></li><li><div>Parser takes the code and checks it syntax to let the user know if there are any syntax issues in the code.</div></li><li><div>If everything is well then a abstract syntax tree is created and the code is now converted to machine code</div></li><li><div>The machine code is now run by the machine</div></li></ul><div><br/></div><div><br/></div><div><img src="JS%20Behind%20the%20scenes.html.resources/Screenshot%202020-01-23%20at%2010.48.09.png" height="882" width="728"/><br/></div><div><br/></div><ul><li><div>The environment in which our code runs is called an Execution Context. </div></li><li><div>The default execution context is the Global Execution Context</div></li><li><div>In a Global Execution Context all the code that is not within any function will be run (for variables and functions that are not inside any other function)</div></li><li><div>Can think of the Global execution context as an Object and can assume it to be the Global object</div></li><li><div>In the browser, the Global execution context is the browser window object. So all the code in the global execution context will  get attached to the window object.</div></li></ul><div><br/></div><div><br/></div><div><img src="JS%20Behind%20the%20scenes.html.resources/Screenshot%202020-01-23%20at%2011.01.19.png" height="1750" width="3130"/><br/></div><div><br/></div><div>In the above picture, we see the Global Execution Context. The var name, and all the functions are declared in the Global execution context. But since no function is called until the last line we are still in the global context. Once the execution reaches the last line (which is calling the function first() ), we will have another execution stack on top of the Global Execution context, that is for the function first. SO calling every new function means the function gets its own new execution context. </div><div><br/></div><div><img src="JS%20Behind%20the%20scenes.html.resources/Screenshot%202020-01-23%20at%2011.01.19.png" height="1750" width="3130"/><br/></div><div><br/></div><div>In this <span style="font-style: italic;">function first() execution stack</span>, the function starts executing and in the second line of the function,<span style="font-style: italic;"> function second()</span> is called, which will now create another execution context for the second function() on top of the current <span style="font-style: italic;">global execution context</span> and <span style="font-style: italic;">function first() execution context. </span><span style="font-weight: bold;">Now this becomes the active execution context as shown by the red arrow. </span>The "var a" will now be stored in the <span style="font-style: italic;">Execution Context first() </span>and not in the Global Execution Context.<span style="font-style: italic;"> </span></div><div><i><img src="JS%20Behind%20the%20scenes.html.resources/Screenshot%202020-01-23%20at%2011.52.12.png" height="1036" width="1898"/><br/></i></div><div><br/></div><div>Similarly for the <span style="font-style: italic;">second() function</span>:</div><div><i><img src="JS%20Behind%20the%20scenes.html.resources/Screenshot%202020-01-23%20at%2011.17.38.png" height="1012" width="1846"/><br/></i></div><div><br/></div><div>Now, the same happens within the <span style="font-style: italic;">second() function</span> and another execution context for function third() is created on top of <span style="font-style: italic;">function second() execution context</span>.</div><div><br/></div><div><img src="JS%20Behind%20the%20scenes.html.resources/Screenshot%202020-01-23%20at%2011.34.41.png" height="1050" width="1892"/><br/></div><div><br/></div><div>Once the execution within <span style="font-style: italic;">function third()</span> is complete, the function returns and the execution context for <span style="font-style: italic;">function third()</span> is closed/removed. </div><div><img src="JS%20Behind%20the%20scenes.html.resources/Screenshot%202020-01-23%20at%2011.38.04.png" height="1010" width="1854"/><br/></div><div><br/></div><div>Now again the execution context returns to <span style="font-style: italic;">function second() execution context</span> and once all the execution within the <span style="font-style: italic;">second() function</span> is complete this execution context too is removed and function is returned.</div><div><br/></div><div><img src="JS%20Behind%20the%20scenes.html.resources/Screenshot%202020-01-23%20at%2011.38.42.png" height="1010" width="1870"/><br/></div><div>Now the same happens in the <span style="font-style: italic;">function one() execution context</span> as well and this function too is returned and we are back at the Global Execution Context. </div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div>The Execution Context in Detail</div><div><img src="JS%20Behind%20the%20scenes.html.resources/Screenshot%202020-01-23%20at%2012.17.34.png" height="1136" width="2142"/><br/></div><div><br/></div><div>Let us consider the execution context as an object. Within the execution context object we have three main properties - </div><ul><li><div>Variable Object (VO) - contains function arguments, inner variable declarations as well as function declarations.</div></li><li><div>Scope Chain - contains the current VO and also the VO’s of its parents</div></li><li><div>“this” variable</div></li></ul><div>When a function is called, we have a new execution context that is put on top of the execution stack and this happens in two phases:</div><ol><li><div>Creation phase - properties of the execution context object are defined here</div></li><ol><li><div>Creation of the VO - </div><div><br/></div><div><img src="JS%20Behind%20the%20scenes.html.resources/Screenshot%202020-01-23%20at%2012.56.47.png" height="926" width="1912"/></div><div><br/></div><div>Hoisting - functions and variables are available even before the execution of the code in JS. Functions are already defined before the execution phase starts. Variables are set to undefined and are defined only in the execution phase</div><div><br/></div><div><span style="font-weight: bold;">Hoisting for functions -  work only for function declarations and not for function expressions. Calling a function expression before defining it causes an “Uncaught TypeError: function not defined” whereas calling a function declaration before defining it still works as it is hoisted.</span> </div><div><br/></div><div>Hoisting for Variables - work differently to functions, when variables are hoisted, they are shown as “undefined” if they are defined in the code. If they aren’t defined then we see “Uncaught ReferenceError: variable not defined” for the variable. The variables are defined only in the Execution phase.</div><div><br/></div><div>Hoisting of function declarations is the most useful part of Hoisting as it means the functions are available even before execution</div><div><br/></div></li><li><div>Creation of scope chain</div><div>Scoping - where can we access a certain variable/ function</div><div>Scope - a place where variables and functions are available</div><div>In JS a new scope is only created by writing a new function</div><div><img src="JS%20Behind%20the%20scenes.html.resources/Screenshot%202020-01-23%20at%2014.09.30.png" height="876" width="1942"/></div><div><br/></div><div>The scope chain works from inside to outside (from child functions to its parent functions); so child functions can see anything in their parent functions and in the global scope but not vice versa (that’s why the scope chain arrow is in red and pointing outwards from the inner scope)<img src="JS%20Behind%20the%20scenes.html.resources/Screenshot%202020-01-23%20at%2014.13.31.png" height="1028" width="1898"/></div><div><br/></div><div><img src="JS%20Behind%20the%20scenes.html.resources/Screenshot%202020-01-23%20at%2014.27.06.png" height="1056" width="1944"/></div></li><li><div>Determine value of ‘this' variable</div><div>It is a variable that each and every execution context gets, is stored in the execution context object.</div><div>In a regular function call, <i>this</i> keyword points to the global object and this is the <b><i>default</i></b>.</div><div>Method ( method is a function that is attached to an object) - <i>this </i>variable points to the object that is calling the method. The <i>this </i>keyword is only assigned a value as soon as the object calls the method. (e.g:  object calling a method to calculate the bmi. In this case, the method calcBmi (John.calcBmi) is called which then makes sure that <i>this</i> is assigned a value (which is the object itself)) </div><div><br/></div><div><img src="JS%20Behind%20the%20scenes.html.resources/Screenshot%202020-01-23%20at%2014.44.52.png" height="1044" width="1950"/></div><div>The <i>this</i> keyword is attached to the execution context and is created as soon as a function is invoked.</div><div><br/></div><div><br/></div><div><br/></div></li></ol><li><div>Execution phase - the code of the function that generates the execution context is run line by line and all the variables are defined. If it is a global context, the global code is run. </div></li></ol><div><br/></div><div><br/></div><div><br/></div></body></html>